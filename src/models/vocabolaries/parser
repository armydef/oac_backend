const fs = require('fs');
const path = require('path');
const libxmljs = require('libxmljs2');
const { exec } = require('child_process');
const stripBom = require('strip-bom').default;
const config = require('../../config');
const VocabPrefix = config.fuseki.vocabularies.prefix || 'diagnostica';


const transformMode = {
    default: 'default',
    forInsert: 'forInsert'
}

class Parser{
    
    static _INSTANCE = null;

    constructor(){
        let xsdPath = path.join(__dirname, 'vocabolaries.xsd');
        this.xsltPath = {
            default: path.join(__dirname, 'vocabolaries.xslt'),
            forInsert: path.join(__dirname, 'vocabolaries_for_insert.xslt')
        };
        this.xsdData = fs.readFileSync(xsdPath, 'utf8');
        this.xsdDoc = libxmljs.parseXml(this.xsdData);
        //this.xsltData = fs.readFileSync(this.xsltPath, 'utf8');
        //this.xslt = xmlParser.xmlParse(this.xsltData);
        this.xsltDoc = libxmljs.parseXml(this.xsdData);
    }

    _getXmlData(xmlPath){
        let _xmlData = fs.readFileSync(xmlPath, 'utf8');
        let xmlData = stripBom(_xmlData);
        return xmlData;
    }

    parse(xmlPath){
        let xmlData = this._getXmlData(xmlPath);
        let xmlDoc = libxmljs.parseXml(xmlData);
        let validation = xmlDoc.validate(this.xsdDoc);
        if (!validation) {
            throw new Error(`XML validation failed: ${xmlDoc.validationErrors}`);
        }
        return xmlDoc;
    }

    validate(xmlPath){
        let result = {
            status: true, message: ''
        };
        try{
            this.parse(xmlPath);
        }catch(e){
            result.status = false;
            result.message = `XML validation failed: ${e.message}`;
        }
        return result
    }

    transform(xmlPath, using=transformMode.default){
        return new Promise((resolve, reject) => {
            let xsltPath = this.xsltPath[using] || this.xsltPath.default;
            try{
                let command = 'xsltproc --stringparam prefix ' + VocabPrefix + ' ';
                command += xsltPath + ' ' + xmlPath    
                exec(command, (err, stdout, stderr) => {
                    if (err) {
                        reject(err)
                    }else{
                        var terms = stdout.split('\n')
                        resolve(terms.map(line => line.trim()).filter(line => line.length > 0));
                    }
                });                
            }catch(e){
                reject(e)        
            }
            
            /*    
            let xmlData = this._getXmlData(xmlPath);
            const xml = xmlParser.xmlParse(xmlData);
            xslt.xsltProcess(xml, this.xslt)
            .then(result => {
                var terms = result.split('&#10;')
                resolve(terms.map(line => line.trim()).filter(line => line.length > 0));
            }).catch(err => {
                reject(err)
            });
            */
        });
    }

    insertQuery(xmlPath){
        return new Promise((resolve, reject) => {
            this.transform(xmlPath, transformMode.forInsert).then(terms => {
                let query = `
                PREFIX crm: <http://www.cidoc-crm.org/cidoc-crm/>
                PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

                INSERT {
                    ?term a crm:E55_Type ;
                    rdfs:label ?label ;
                    crm:P127_has_broader_term ?broader .
                }
                WHERE {
                    VALUES (?term ?label ?broader) {
                        ${terms.join(' \n')}
                    }
                    FILTER NOT EXISTS {
                        ?term rdfs:label ?label .
                    }
                }`
                resolve(query);
            }).catch(err => {
                reject(err);
            });
        })
    }

    static GET_INSTANCE(){
        if (Parser._INSTANCE === null) {
            Parser._INSTANCE = new Parser();
        }
        return Parser._INSTANCE;
    }
}

module.exports = { Parser, transformMode };